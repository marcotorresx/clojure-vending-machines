(ns evidencia2.transacciones)


;; --- MODIFY INVENTORY ---
;; Function that modifies the inventory quantity depending on the operator
;; (inventory, previous-inv, element, operator) -> (new inventory)

(defn modificar-inventario [inventario inv-anterior elemento operador]
  (cond
    ; If the data of the searched element is found
    (= elemento (get (first inventario) 0))
    ; Return a new list that combines
    (concat
     ; The data of previous elements
     inv-anterior
     ; The data of the searched element applying the operator to the inventory quantity
     (list [(get (first inventario) 0)
            (operador (get (first inventario) 1) 1)
            (get (first inventario) 2)])
     ; The data of the remaining elements
     (rest inventario))

    ; Recursively call the function passing
    :else (modificar-inventario
           ; The remaining elements
           (rest inventario)
           ; Append the current data to the list of previous data
           (concat inv-anterior (list (first inventario)))
           elemento operador)))


;;  --- MODIFY-INVENTORY? ---
;; Function that returns whether the modification of the coin inventory is valid depending on the operator
;; (coin-inv, coin, operator) -> (1 or exit status)

(defn modificar-inventario? [inv-monedas moneda operador]
  (cond
    ; If the coin is found
    (= moneda (get (first inv-monedas) 0))
    (cond
      ; If the operator is - and the coin has 0 inventory, return exit status -1-1
      (and (= operador -) (<= (get (first inv-monedas) 1) 0)) -1
      ; If the operator is + and the quantity is equal to the maximum quantity, return exit status -2
      (and (= operador +) (>= (get (first inv-monedas) 1) (get (first inv-monedas) 2))) -2
      ; If the modification is valid, return 1
      :else 1)

    ; Continue searching
    :else (modificar-inventario? (rest inv-monedas) moneda operador)))


;; --- SEARCH PRODUCT ---
;; Function that searches for the transaction product
;; (product, inventory-products, unchanged-inventory-products) -> ('(price, new inventory-products) or exit status)

(defn buscar-producto [producto inv-productos todos-productos]
  (cond
    ; If the product is not found, return exit status -1
    (empty? inv-productos) -1
    ; If the product is found
    (= producto (get (first inv-productos) 0))
    ; Check if it's in inventory
    (cond
      ; If it's out of stock, return exit status -2
      (<= (get (first inv-productos) 1) 0) -2

      ; If it's in stock, return a list with the price
      :else (list (get (first inv-productos) 2)
                  ; And with the new inventory
                  (modificar-inventario todos-productos '() producto -)))

    ; Keep searching
    :else (buscar-producto producto (rest inv-productos) todos-productos)))


;; --- ADD COINS ---
;; Function that returns the new coin inventory with added coins or exit status
;; (coin-inventory, inserted-coins) -> (new coin-inventory or exit status)

(defn agregar-monedas [inv-monedas monedas]
  (cond
    ; If there are no more coins to add, return the new inventory
    (empty? monedas) inv-monedas
    ; If the coin can't be added because the inventory is full, return exit status -1
    (< (modificar-inventario? inv-monedas (first monedas) +) 0) -1

    ; Call the function recursively
    :else (agregar-monedas
           ; Passing the new inventory with the incremented coin count
           (modificar-inventario inv-monedas '() (first monedas) +)
           ; Analyze the next coin
           (rest monedas))))


;; --- CALCULATE CHANGE ---
;; Function that calculates the transaction change and generates the new coin inventory
;; (change-amount, change-coins, coin-inventory, values) -> ( '(change, new coin-inventory) )

(defn calcula-cambio [cant-cambio m-cambio inv-monedas valores]
  (cond
    ; If the change amount is 0, return a list with the change coins and the new inventory
    (<= cant-cambio 0) (list m-cambio inv-monedas)
    ; If all the values have been tried, there is not enough change, return exit status -3
    (empty? valores) -3

    :else
    (cond
       ; If the current value is smaller than the change amount and its inventory can be decreased by 1
      (and (<= (first valores) cant-cambio) (> (modificar-inventario? inv-monedas (first valores) -) 0))

       ; Call the function recursively
      (calcula-cambio
         ; The new change amount is the subtraction between the current amount and the current value
       (- cant-cambio (first valores))
         ; The current coin is added to the change coins
       (concat m-cambio (list (first valores)))
         ; The new inventory is generated by subtracting 1 from the count
       (modificar-inventario inv-monedas '() (first valores) -)
         ; The values are kept to check the current value
       valores)

       ; If the current value is greater than the change amount or its inventory cannot be decreased by 1
      :else (calcula-cambio cant-cambio m-cambio inv-monedas (rest valores)))))


;; --- VALIDATE COINS ---
;; Function that validates the entered coins based on a finite automaton and calls 'calcula-cambio' or returns output state
;; (entered amount, entered coins, price, coins inventory) -> ('(change, new-coins-inv))

(defn validar-monedas [cant-ingresada m-ingresadas precio inv-monedas]
  (cond
    ; If there are no more coins
    (empty? m-ingresadas)
    (if
     ; If the final state is not an accepting state (not greater than the price), return output state -1
     (< cant-ingresada precio) -1

    ; If it is correct, call 'calcula-cambio' and return the change and new inventory or output states
     (calcula-cambio
      ; The amount of change is the difference between the entered money and the price
      (- cant-ingresada precio) '() inv-monedas
      ; Pass a list of coin values in decreasing order
      (reverse (map first inv-monedas))))

    ; Iterate over the values and check if the coin is valid or return output state -2
    (<= (apply + (map (fn [valor] (if (= valor (first m-ingresadas)) 1 0)) (map first inv-monedas))) 0) -2

    ; Recursively call function with sum of amount with currency
    :else (validar-monedas (+ cant-ingresada (first m-ingresadas)) (rest m-ingresadas) precio inv-monedas)))


;; --- PROCESS TRANSACTION ---
;; Function that processes a transaction and returns the profit and the result to print
;; (machine id, transaction, product inventory, coin inventory, price result, change result, bool added coins)
;; -> (transaction profit and list with data to print result)
(defn procesa-transaccion [id-maquina transaccion inv-productos inv-monedas res-precio res-cambio m-agregadas]
  (cond

    ; --- VERIFY PRICE AND PRODUCT ---
    ; If there is no res-precio, it means the product has not been searched yet
    (nil? res-precio)
    ; Call the function recursively
    (procesa-transaccion id-maquina transaccion inv-productos inv-monedas
                         ; Passing as a parameter for res-precio the result of buscar-producto
                         (buscar-producto (get transaccion 1)
                                          ; An inventory is passed to iterate over
                                          inv-productos
                                          ; Another inventory is passed to subtract the quantity
                                          inv-productos)
                         res-cambio m-agregadas)
    ; --- VALIDATIONS ---
    ; If res-precio is -1, it means the product was not found. Mark error and return profit 0
    (= res-precio -1)
    ; The outputs are a list with the profit and a sublist with the data to print the result
    (list 0 (list 0 (get transaccion 0) "Product not found"
                (get transaccion 1) 0 0 (get transaccion 2)))
    ; If res-precio is -2, it means there is no inventory. Mark error and return profit 0
    (= res-precio -2)
    (list 0 (list 0 (get transaccion 0) "Product inventory is empty"
                (get transaccion 1) 0 0 (get transaccion 2)))

    ; --- VERIFY COINS AND CALCULATE CHANGE ---
    ; If there is no res-cambio, it means the coins and change have not been processed yet
    (nil? res-cambio)
    ; Call the function recursively
    (procesa-transaccion id-maquina transaccion inv-productos inv-monedas res-precio
                         ; Passing as a parameter for res-cambio the result of validar-monedas
                         (validar-monedas
                          0
                          ; Coins inserted
                          (get transaccion 2)
                          ; Pass the product price
                          (first res-precio) inv-monedas)
                         m-agregadas)
    ; --- VALIDATIONS ---
    ; If res-cambio is -1, it means the product price was not reached, return profit 0
    (= res-cambio -1)
    (list 0 (list 0 (get transaccion 0) "Insufficient money"
              (get transaccion 1) 0 0 (get transaccion 2)))
    ; If res-cambio is -2, it means an invalid coin was inserted, return profit 0
    (= res-cambio -2)
    (list 0 (list 0 (get transaccion 0) "Invalid coin inserted"
              (get transaccion 1) 0 0 (get transaccion 2)))
    ; If res-cambio is -3, it means there was not enough change, return profit 0
    (= res-cambio -3)
    (list 0 (list 0 (get transaccion 0) "Cannot deliver change"
              (get transaccion 1) 0 0 (get transaccion 2)))


    ; --- ADD INCOMING COINS TO INVENTORY ---
    ; If there are no added coins, it means that the coins have not yet been added
    (nil? m-agregadas)
      ; Call the function recursively
    (procesa-transaccion id-maquina transaccion inv-productos
                          ; Generate new inventory using the inventory result of the change
                        (agregar-monedas (second res-cambio) (get transaccion 2))
                          ; Change added coins to 1 to indicate operation performed
                        res-precio res-cambio 1)
    ; --- VALIDATIONS ---
    ; If inv-monedas is -1, there was not enough space, return profit 0
    (= inv-monedas -1)
    (list 0 (list 0 (get transaccion 0) "No hay suficiente espacio en inventario"
                              (get transaccion 1) 0 0 (get transaccion 2)))

    ; If everything is correct
    :else (do
            ; Update the inventory file of the machine
            (spit (str "data/" id-maquina "/i.txt") 
                  {:maquina id-maquina :inv-productos (second res-precio) :inv-monedas inv-monedas})
            ; Return profit and list with data for successful sale printing
            (list (first res-precio) (list 1 (get transaccion 0) "Venta exitosa"
                  (get transaccion 1) (first res-precio) (apply + (get transaccion 2)) (first res-cambio))))))


;; --- INVENTORY ALERT ---
;; Function that generates list of products or coins in alert
;; (inventory, <= or >, + or -, margin) -> (elements in alert)

(defn alerta-inventario [inventario operador-1 operador-2 margen]
  (cond
    ; If all elements have been processed, return empty list
    (empty? inventario) nil
    ; If there is an alert
    (operador-1 (get (first inventario) 1) (operador-2 (if (= operador-1 <=) 0 (get (first inventario) 2)) margen))
    ; Add element to the list
    (cons (get (first inventario) 0) (alerta-inventario (rest inventario) operador-1 operador-2 margen))

    ; If there is no alert, move to the next element
    :else (alerta-inventario (rest inventario) operador-1 operador-2 margen)))


;; --- PROCESS-MACHINE ---
;; Function that iterates through the transactions of a machine and processes them
;; (machine ID, transactions, total earnings, transaction results) -> (nil)
  
(defn procesar-maquina [id-maquina transacciones ganancia-total resultados]
  ; If there are no more transactions left
  (if (empty? transacciones)

    ; Open the final inventories to check alerts
    (let [inventarios (read-string (slurp (str "data/" id-maquina "/i.txt")))]
      ; Save the results of processing the machine in a file
      (spit (str "data/" id-maquina "/r.txt")
            {:maquina id-maquina :ganancia ganancia-total :resultados resultados
             ; Obtain inventory alerts
             :alertas-prod-min (alerta-inventario (get inventarios :inv-productos) <= + 3)
             :alertas-mon-min (alerta-inventario (get inventarios :inv-monedas) <= + 2)
             :alertas-mon-max (alerta-inventario (get inventarios :inv-monedas) > - 2)}))

    ; Get updated inventories for the machine
    (let [inventarios (read-string (slurp (str "data/" id-maquina "/i.txt")))]
      ; Process the transaction and get the result which is the earnings and the result string
      (let [resultado (procesa-transaccion id-maquina (first transacciones)
                                           (get inventarios :inv-productos) (get inventarios :inv-monedas) nil nil nil)]

        ; Move on to the next transaction
        (procesar-maquina id-maquina (rest transacciones)
                              ; Adding the earnings of this transaction
                              (+ ganancia-total (first resultado))
                              ; Adding the result of this transaction
                              (concat resultados (list (second resultado))))))))